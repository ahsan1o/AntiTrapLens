"""
Markdown reporter for AntiTrapLens.
"""

from pathlib import Path
from typing import Dict, Any
from ...core.types import ScanResult
from ..base import BaseReporter
from ..common import DataConverter

class MarkdownReporter(BaseReporter):
    """Markdown-based report generator."""

    def __init__(self, config=None):
        super().__init__(config)

    def generate(self, scan_result: ScanResult, output_path: str = None) -> str:
        """Generate Markdown report."""
        if output_path is None:
            output_path = "antitraplens_report.md"

        markdown_content = self._generate_markdown(scan_result)

        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(markdown_content)

        return f"Markdown report saved to {output_path}"

    def _generate_markdown(self, scan_result: ScanResult) -> str:
        """Generate Markdown content."""
        scan_info = scan_result.scan_info
        pages = scan_result.pages

        markdown = self._generate_project_header_md()
        markdown += self._generate_header(scan_info)
        markdown += self._generate_page_details(pages)
        markdown += self._generate_summary_table(pages, scan_info)
        markdown += self._generate_footer_md()

        return markdown

    def _generate_project_header_md(self) -> str:
        """Generate project header for markdown."""
        return """# AntiTrapLens
## Privacy & Dark Pattern Detection Tool

**Created by:** Ahsan Malik  
**GitHub:** [https://github.com/ahsan1o/AntiTrapLens](https://github.com/ahsan1o/AntiTrapLens)

---

"""

    def _generate_footer_md(self) -> str:
        """Generate footer for markdown."""
        return f"""

---

**Report generated by AntiTrapLens**  
*Author: Ahsan Malik*  
*GitHub: [https://github.com/ahsan1o/AntiTrapLens](https://github.com/ahsan1o/AntiTrapLens)*  
*Generated on: {__import__('datetime').datetime.now().strftime('%Y-%m-%d %H:%M:%S')}*
"""

    def _generate_header(self, scan_info: Dict[str, Any]) -> str:
        """Generate markdown header."""
        return f"""# AntiTrapLens Report

## Scan Summary

- **Start URL**: {scan_info.get('start_url', 'N/A')}
- **Pages Scanned**: {scan_info.get('pages_scanned', 0)}
- **Total Findings**: {scan_info.get('total_findings', 0)}
- **Timestamp**: {scan_info.get('timestamp', 'N/A')}

## Page Details

"""

    def _generate_page_details(self, pages) -> str:
        """Generate page details section."""
        markdown = ""
        for i, page in enumerate(pages):
            category = getattr(page, 'category', 'General')
            title = getattr(page, 'title', 'Untitled Page')
            markdown += f"""### Page {i+1}: [{page.url}]({page.url})
**Category**: {category}  
**Title**: {title}

"""
            markdown += self._generate_tracking_access_section(page)
            markdown += self._generate_dark_patterns_section(page)
            markdown += self._generate_cookies_section(page)
        return markdown

    def _generate_dark_patterns_section(self, page) -> str:
        """Generate dark patterns section for markdown."""
        findings_md = self._generate_page_findings(page)
        score_md = self._generate_page_score(page)
        
        if findings_md.strip() or score_md.strip():
            return f"""#### ðŸŽ­ Dark Patterns Analysis

> **About Dark Patterns:** These are user interface designs that manipulate or deceive users into making decisions they might not otherwise make.

{findings_md}{score_md}"""
        return ""

    def _generate_cookies_section(self, page) -> str:
        """Generate cookies section for markdown."""
        cookies_md = self._generate_page_cookies(page)
        
        if cookies_md.strip():
            return f"""#### ðŸª Cookies & Tracking Analysis

> **About Cookies & Tracking:** This section analyzes cookies and tracking mechanisms that monitor your browsing behavior and collect personal data.

**âš ï¸ Important:** These are the websites that will start tracking you if you give them cookie consent on this page.

{cookies_md}"""
        return ""

    def _generate_tracking_access_section(self, page) -> str:
        """Generate tracking access section for markdown."""
        if not hasattr(page, 'tracking_access') or page.tracking_access['access_summary']['total_tracking_domains'] == 0:
            return ""
        
        tracking = page.tracking_access
        markdown = f"""
## ðŸš¨ Tracking Access Warning

**Accepting cookies will grant tracking access to {tracking['access_summary']['total_tracking_domains']} domains**

### Domains That Will Track You:
"""
        
        for domain in list(tracking['all_tracking_domains'])[:10]:  # Show first 10
            tracker_type = self._get_tracker_type_md(domain)
            markdown += f"- **{domain}** - {tracker_type}\n"
        
        if len(tracking['all_tracking_domains']) > 10:
            remaining = len(tracking['all_tracking_domains']) - 10
            markdown += f"- ... and {remaining} more tracking domains\n"
        
        markdown += f"""
### Summary
Your browsing data will be shared with **{len(tracking['all_tracking_domains'])} companies** for tracking and analytics purposes.

"""
        return markdown
    
    def _get_tracker_type_md(self, domain: str) -> str:
        """Get markdown display text for tracker type."""
        domain = domain.lower()
        if 'google' in domain:
            return 'Google Analytics & Advertising'
        elif 'facebook' in domain:
            return 'Facebook Social Tracking'
        elif 'twitter' in domain:
            return 'Twitter Social Media'
        elif 'hotjar' in domain:
            return 'Hotjar User Experience'
        elif 'mixpanel' in domain:
            return 'Mixpanel Product Analytics'
        elif 'doubleclick' in domain:
            return 'Google Advertising'
        else:
            return 'Tracking & Analytics'

    def _generate_page_cookies(self, page) -> str:
        """Generate cookie information for a page with enhanced descriptions."""
        if not hasattr(page, 'cookies') or not page.cookies:
            cookies_md = ""
        else:
            cookies_md = f"""#### Cookies
- **Total Cookies**: {len(page.cookies)}
"""
            third_party = [c for c in page.cookies if c.is_third_party]
            if third_party:
                cookies_md += f"- **Third-party Cookies**: {len(third_party)}\n"

            if hasattr(page, 'cookie_access_analysis'):
                analysis = page.cookie_access_analysis
                if analysis.get('data_collection'):
                    cookies_md += f"- **Data Collection**: {', '.join(analysis['data_collection'][:3])}\n"
                if analysis.get('privacy_concerns'):
                    cookies_md += f"- **Privacy Issues**: {len(analysis['privacy_concerns'])}\n"

        # Add cookie findings with descriptions
        cookie_findings_md = ""
        if hasattr(page, 'dark_patterns'):
            cookie_findings = [f for f in page.dark_patterns.findings 
                             if DataConverter.is_cookie_tracking_pattern(f.pattern)]
            if cookie_findings:
                cookie_findings_md += f"\n#### Cookie & Tracking Findings ({len(cookie_findings)})\n"
                for finding in cookie_findings:
                    severity_emoji = {'high': 'ðŸ”´', 'medium': 'ðŸŸ¡', 'low': 'ðŸŸ¢'}.get(finding.severity.lower(), 'âšª')
                    pattern_info = DataConverter.get_pattern_description(finding.pattern)
                    
                    cookie_findings_md += f"- {severity_emoji} **{finding.pattern.replace('_', ' ').title()}** ({finding.severity.upper()})\n"
                    cookie_findings_md += f"  - *Detection:* {finding.description}\n"
                    cookie_findings_md += f"  - *What this means:* {pattern_info['description']}\n"
                    cookie_findings_md += f"  - *How it affects you:* {pattern_info['user_impact']}\n\n"

        return cookies_md + cookie_findings_md

    def _generate_page_findings(self, page) -> str:
        """Generate findings for a page with enhanced descriptions."""
        if not hasattr(page, 'dark_patterns') or not page.dark_patterns.findings:
            return ""

        # Filter out cookie-related findings
        dark_findings = [f for f in page.dark_patterns.findings 
                        if DataConverter.is_dark_pattern(f.pattern)]
        
        if not dark_findings:
            return ""

        markdown = f"""#### Dark Patterns ({len(dark_findings)})
"""
        for finding in dark_findings:
            severity_emoji = {'high': 'ðŸ”´', 'medium': 'ðŸŸ¡', 'low': 'ðŸŸ¢'}.get(finding.severity.lower(), 'âšª')
            pattern_info = DataConverter.get_pattern_description(finding.pattern)
            
            markdown += f"- {severity_emoji} **{finding.pattern.replace('_', ' ').title()}** ({finding.severity.upper()})\n"
            markdown += f"  - *Detection:* {finding.description}\n"
            markdown += f"  - *What this means:* {pattern_info['description']}\n"
            markdown += f"  - *How it affects you:* {pattern_info['user_impact']}\n\n"

        return markdown

    def _generate_page_dark_patterns(self, page) -> str:
        """Generate dark patterns section for a page."""
        findings_md = self._generate_page_findings(page)
        score_md = self._generate_page_score(page)
        return findings_md + score_md

    def _generate_page_score(self, page) -> str:
        """Generate score for a page."""
        if not hasattr(page, 'dark_patterns') or not page.dark_patterns.score:
            return ""

        score = page.dark_patterns.score
        grade = score.get('grade', 'N/A')
        total_score = score.get('total_score', 0)
        return f"""#### Score
**{total_score}/100 ({grade})**

"""

    def _generate_summary_table(self, pages, scan_info: Dict[str, Any]) -> str:
        """Generate summary table with enhanced information."""
        dark_pattern_counts = DataConverter.get_dark_pattern_summary(pages)
        cookie_counts = DataConverter.get_cookie_summary(pages)

        if not dark_pattern_counts and not cookie_counts:
            return ""

        markdown = "## Findings Summary\n"

        if dark_pattern_counts:
            markdown += "\n### ðŸŽ­ Dark Patterns Detected\n\n"
            markdown += "*Dark patterns are manipulative design elements that trick users into unintended actions.*\n\n"
            markdown += "| Pattern | Count | Severity | Description |\n|---------|-------|----------|-------------|\n"
            for pattern, data in sorted(dark_pattern_counts.items(), key=lambda x: x[1]['count'], reverse=True):
                severity_emoji = {'high': 'ðŸ”´', 'medium': 'ðŸŸ¡', 'low': 'ðŸŸ¢'}.get(data['severity'].lower(), 'âšª')
                pattern_info = DataConverter.get_pattern_description(pattern)
                markdown += f"| {pattern.replace('_', ' ').title()} | {data['count']} | {severity_emoji} {data['severity']} | {pattern_info['description']} |\n"

        if cookie_counts:
            markdown += "\n### ðŸª Cookie & Tracking Issues\n\n"
            markdown += "*These issues relate to how the website tracks your behavior and collects your data.*\n\n"
            markdown += "| Pattern | Count | Severity | Description |\n|---------|-------|----------|-------------|\n"
            for pattern, data in sorted(cookie_counts.items(), key=lambda x: x[1]['count'], reverse=True):
                severity_emoji = {'high': 'ðŸ”´', 'medium': 'ðŸŸ¡', 'low': 'ðŸŸ¢'}.get(data['severity'].lower(), 'âšª')
                pattern_info = DataConverter.get_pattern_description(pattern)
                markdown += f"| {pattern.replace('_', ' ').title()} | {data['count']} | {severity_emoji} {data['severity']} | {pattern_info['description']} |\n"

        return markdown

    def get_format(self) -> str:
        """Get report format."""
        return "markdown"
